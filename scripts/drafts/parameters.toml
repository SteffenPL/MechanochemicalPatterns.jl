[env]
    damping = 0.1              # pg/hr (makes mass non-dimensional)
    domain = { center = [0.0, 0, 75], size = [500.0, 500, 150] }   # μm
    gravity = [0.0,0.0,-1.0]      # pg / hr^2

[sim]
    t_end   = "julia: 4*24.0"  # hr
    dt      = 0.01  # hr
    saveat  = 0.1   # hr

    [sim.collision_detection]
        grid = [50, 50, 10]     # number of boxes for collision detection 
        margin = 1.0            # normalized % for extra space around domain

[signals]
    dx = 0.01   # μm

    [signals.types.u]
        D = 0.1                     # unit ???
        initial_distr = """julia: 
                        function (x, p)
                            std = 5.0
                            return exp( -dist(x, domain.center)^2 / (2 * std^2) )
                        end
                        """

[cells]
    R_soft = 8.0        # μm
    R_hard = 5.0        # μm 
    R_adh = 6.0      # μm
    R_interact = 8.0    # μm (maximal interaction range)
    lifespan = 24.0     # hr
    repulsion_stiffness = 0.1
    sigma = 0.0         # μm / √hr (for random walk)

    new_adh_rate = 1.0  # 1/hr
    adh_duration = 20.0  # hr

    init = {R = 150.0}

    [cells.init_pos.custom_distr]
        domain_fnc = """julia: 
            function (x, p)
                R = p.cells.init.R
                c = (0, 0, 50)
                return R^2 - ((x[1]-c[1])^2 + (x[2]-c[2])^2 + (x[3]-c[3])^2)
            end"""
        domain_bounds = { center = [0.0, 0.0, 75.0], size = [500.0, 500.0, 150.0] }

    [cells.types.proximal]
        ID = 1
        N = 200
        adhesion_stiffness = 0.01
        attraction_stiffness = 0.0


    [cells.types.distal]
        ID = 2
        N = 100
        adhesion_stiffness = 0.06
        attraction_stiffness = 0.0

        [cells.types.distal.init_pos.custom_distr]
                distr = """julia: 
                    function (x, p)
                        dom = p.env.domain
                        if rand() < 0.3
                            rand!(x)
                            @. x = dom.center + (0.5 - x) .* dom.size
                        else
                            sigma = 50
                            center = (0, 50, 50)
                            randn!(x)
                            @. x = x * sigma + center
                        end
                    end
                    """
                domain_fnc = """julia: 
                    function (x, p)
                        R = p.cells.init.R
                        c = (0, 0, 50)
                        return R^2 - ((x[1]-c[1])^2 + (x[2]-c[2])^2 + (x[3]-c[3])^2)
                    end"""
                domain_bounds = { center = [0.0, 0.0, 75.0], size = [500.0, 500.0, 150.0] }


        # init_pos = {normal = {mean = [0.0,50,75], std = [30,30,15]}}

    [cells.interaction]
        adhesion_stiffness = 1.5

